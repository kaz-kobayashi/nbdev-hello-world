[
  {
    "objectID": "shortestpath.html",
    "href": "shortestpath.html",
    "title": "最短路問題",
    "section": "",
    "text": "扱いたい場所の住所が書かれたcsvファイルを用意し，CSVアドレスマッチングサービスを用いてそれらの住所に対応する緯度経度を取得する。\nここでは，青山学院大学の青山キャンパスと相模原キャンパスの緯度経度を取得する。具体的には，1行目に東京都渋谷区渋谷4-4-25,2行目に神奈川県相模原市中央区淵野辺5-10-1と書いたcsvファイルをagu.csvという名前で保存する。\n\n東京都渋谷区渋谷4-4-25\n神奈川県相模原市中央区淵野辺5-10-1\n\nCSVアドレスマッチングサービスのページで「変換したいファイル名」でagu.csvを選ぶ。送信ボタンを押すと，これら2つの住所に対応する緯度経度が書かれたcsvファイルがダウンロードされる。これから，東京都渋谷区渋谷4-4-25の緯度経度は(35.66049,139.71027)で，神奈川県相模原市中央区淵野辺5-10-1の緯度経度は(35.56805,139.40280)であることがわかる。これらを，辞書として保存する。\n\nmyadd={\"aocam\":(35.66049,139.71027),\"sagacam\":(35.56805,139.40280)}\n\n\nmyadd[\"aocam\"]\n\n(35.66049, 139.71027)\n\n\n次のセルで定義する関数myshortestpath(from_loc,to_loc)は，from_locを始点，to_locを終点とする最短経路を計算するものである。この経路は，OpenStreetMap上の道路情報を用いて計算される。\nfrom_locとto_locには，それぞれ始点の緯度経度と終点の緯度経度の情報を与える。これらの2点を含む範囲の道路網情報をダウンロードしてグラフGとして保存する。そして，distance.nearest_nodes()によって，G内のノードで始点と終点に最寄りのものをそれぞれ求める。\nそして，shortest_path()によって最短経路を求めて，plot_graph_route()によりグラフGと最短経路pathを併せて表示（プロット）する。\n\nimport osmnx as ox\nimport networkx as nx\nfrom osmnx import distance\nimport folium\ndef myshortestpath(from_loc,to_loc):\n    #起点と終点を含む地域の道路ネットワークを取得\n    north= max(from_loc[0],to_loc[0])\n    south=min(from_loc[0],to_loc[0])\n    east=max(from_loc[1],to_loc[1])\n    west=min(from_loc[1],to_loc[1])\n\n\n    G=ox.graph_from_bbox(north,south,east,west,network_type='drive')\n    #起点と終点のノードを取得\n    from_node=distance.nearest_nodes(G,from_loc[1],from_loc[0])\n    to_node=distance.nearest_nodes(G,to_loc[1],to_loc[0])\n\n    #最短路の計算\n    path=nx.shortest_path(G,from_node,to_node,weight='length')\n    print(\"最短路の距離 {:,} meters\".format(int(nx.shortest_path_length(G,from_node,to_node,weight='length'))))\n    fig,ax=ox.plot_graph_route(G,path,route_color='r',node_size=0)\n\n    return G,path\n\n\nG,path=myshortestpath(myadd[\"aocam\"],myadd[\"sagacam\"])\n\n最短路の距離 32,163 meters\n\n\n\n\n\n\n# explore a route interactively\nroute_edges = ox.utils_graph.route_to_gdf(G, path)\nm=route_edges.explore(tiles=\"cartodbpositron\", style_kwds={\"weight\": 5})\nm\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n上記の関数myshortestpath()で求めた経路の周辺の施設を見つける関数myfeatures()も定める。これは，openstreetmapのタグを指定して，そのタグをもつ施設を地図上に配置するものである。\nダグは，OpenStreetMapのページから見ることができる。例えば，関数myfeatures(from_loc,to_loc,_tags)の_tagsに，{\"amenity\":\"toilets\"}を指定すると，トイレが得られる。\n\ndef myfeatures(from_loc,to_loc,_tags):\n    #起点と終点を含む地域の道路ネットワークを取得\n    north= max(from_loc[0],to_loc[0])\n    south=min(from_loc[0],to_loc[0])\n    east=max(from_loc[1],to_loc[1])\n    west=min(from_loc[1],to_loc[1])\n\n    myfea=ox.features_from_bbox(north,south,east,west,tags=_tags)\n    return myfea\n\n\ntoi=myfeatures(myadd[\"aocam\"],myadd[\"sagacam\"],{\"amenity\":\"toilets\"})\ntoi.explore(m=m,tiles=\"cartodbpositron\",color=\"red\")\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "nbdev-hello-world",
    "section": "",
    "text": "This file will become your README and also the index of your documentation."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "nbdev-hello-world",
    "section": "Install",
    "text": "Install\npip install nbdev_hello_world"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "nbdev-hello-world",
    "section": "How to use",
    "text": "How to use\nFill me in please! Don’t forget code examples:\n\n1+1\n\n2"
  },
  {
    "objectID": "gis-density.html",
    "href": "gis-density.html",
    "title": "人口密度のプロット",
    "section": "",
    "text": "メッシュデータをshapefileとして用意したとする。 myzipfile = “500m_mesh_suikei_2018_shape_10.zip”\n\nmyzipfile = \"500m_mesh_suikei_2018_shape_10.zip\"\n\nimport geopandas as gpd\nfrom zipfile import ZipFile\nimport matplotlib.pyplot as plt\n\n#zipファイルを解答\nwith ZipFile(myzipfile,'r') as zip_ref:\n    zip_ref.extractall()\n\n\ndef plot_density(meshfile):\n    #shapeファイルを読み込む\n    #meshfile=\"500m_mesh_2018_10.shp\"\n    gdf = gpd.read_file(meshfile)\n\n    #座標系を地理座標系からUTM座標系に変換\n    gdf_utm = gdf.to_crs(epsg=32654)\n\n    #各メッシュの面積を平方メートルで計算\n    gdf_utm['area'] = gdf_utm.geometry.area\n\n    #PTN_2015列にある人口を用いて人口密度を計算する。\n    gdf_utm['PTN_2015'] = gdf['PTN_2015']\n    gdf_utm['density'] = gdf_utm['PTN_2015']/gdf_utm['area']\n\n    #人口密度をプロットする\n    gdf_utm.plot(column='density', legend=True, cmap='viridis')\n    plt.show()\n\n\n\n\n\nmeshfile=\"500m_mesh_2018_10.shp\"\nplot_density(meshfile)"
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "notacore",
    "section": "",
    "text": "source\n\nfoo\n\n foo ()\n\n\nsource\n\n\nsay_hello\n\n say_hello (to)\n\nSay hello to somebody\n\nsay_hello(\"Issac\")\n\n'Hello Issac!'\n\n\n\nassert say_hello(\"Hamel\")==\"Hello Hamel!\""
  },
  {
    "objectID": "facloc.html",
    "href": "facloc.html",
    "title": "施設配置問題",
    "section": "",
    "text": "施設配置問題は，候補地の中からある目的関数を最適化するように実際に施設を配置する場所を選び出す問題である。施設配置問題を知るのに適切な文献として，田中健一，数理最適化入門(4) : 施設配置の数理モデル(チュートリアル)，応用数理23(4),2013が挙げられる。\n施設配置問題を定めるには，需要点の集合\\(I\\)と，配置候補地\\(J\\)を定義する。そして，需要点\\(i \\in I\\)から\\(j \\in J\\)への移動距離\\(d_{ij}\\)が与えられるとする。さらに，需要点\\(i\\)の需要量\\(w_i\\)が与えられるとする。\nまた，配置候補地\\(j \\in J\\)に対して0-1変数\\(x_j\\)を導入する。候補地\\(j \\in J\\)に施設を配置すること1，そうでないとき0をとる変数とする。そして，\\(i \\in I\\)と\\(j \\in J\\)の各ペアに対して，変数\\(y_{ij}\\)を定義する。この変数は，需要\\(i\\)を施設\\(j\\)に配置するとき1，そうでないとき0となる。\n施設配置問題の目的関数は，各需要点から，その需要点に割り当てられた施設への移動距離の重み付き和\\(\\sum_{i \\in I}\\sum_{j \\in J}w_id_{ij}y_{ij}\\)とする。\n制約条件としては，\n\n配置する施設数がちょうど\\(p\\)個となる制約:\n\n\\[\n\\sum_{j \\in J}x_j=p\n\\]\n\n各需要点がちょうど1つの施設に割り当てられることを課す制約\n\n\\[\n\\sum_{j \\in J}y_{ij}=1 \\ \\ \\forall i  \\in I\n\\]\n\n需要点\\(i\\)が施設\\(j\\)に割り当てられるには施設\\(j\\)が配置されている必要があることを課す制約\n\n\\[\ny_{ij} \\leq x_j \\ \\ \\forall i  \\in I,\\ \\forall j  \\in J\n\\]\nを課す。まとめると，施設配置問題は，次の整数計画問題として定式化される。\n\\[\n\\begin{array}{lll}\n\\min&\\displaystyle \\sum_{i  \\in I}\\sum_{j \\in J}w_id_{ij}y_{ij}&\\\\\n\\text{s.t.}&\\displaystyle\\sum_{j \\in J }x_j=p&\\\\\n&\\displaystyle\\sum_{j\\in J}y_{ij}=1&\\ \\forall i  \\in I\\\\\n&y_{ij}\\leq\\ x_j&\\ \\forall i  \\in I\\ \\forall j  \\in J\\\\\n&x_j\\in\\{0,1\\}&\\ \\forall j \\in J\\\\\n&y_{ij}\\in\\{0,1\\}&\\ \\forall i \\in I,\\forall j \\in J.\n\\end{array}\n\\]\nこの整数計画問題を解くためのプログラムを定める。まず，集合\\(I,J\\)，\\(w_i\\)，\\(d_{ij}\\)，\\(p\\)を定めるリストと辞書を定義する。\n\n#需要点の集合の定義\nI=[0,1]\n#配置候補地の集合\nJ=[0,1,2,3,4]\n#需要量の定義\nw={0:10,1:15,2:7,3:9,4:12}\n#施設数の定義\np=2\n\n# costsの定義\ncosts = {\n    (0, 0): 4,\n    (0, 1): 6,\n    (0, 2): 9,\n    (0, 3): 8,\n    (0, 4): 7,\n    (1, 0): 5,\n    (1, 1): 8,\n    (1, 2): 7,\n    (1, 3): 6,\n    (1, 4): 4\n}\n\nこれらを用いて施設配置問題を解く関数facilitylocation()を定める。\n\nfrom pulp import *\n\ndef facilitylocation(I,J,w,costs,p):\n    # 空の線形計画問題を生成する\n    prob = LpProblem(\"FacilityLocation\", LpMinimize)\n\n    # 決定変数を定める\n    y=LpVariable.dicts(\"y\",[(i,j) for i in I for j in J],cat='Binary')\n    x=LpVariable.dicts(\"x\",[j for j in J],cat='Binary')\n\n    # 目的関数の定義\n    prob += lpSum([w[i]*costs[(i, j)] * y[(i, j)] for j in J] for i in I)\n\n    # 制約条件の定義\n    prob+=lpSum([x[j] for j in J])==p\n\n    for i in I:\n        prob+=lpSum([y[(i,j)] for j in J])==1\n\n    for i in I:\n        for j in J:\n            prob+=y[(i,j)]&lt;=x[j]\n\n    # 最適化の実行\n    prob.solve();\n\n    # Print the results\n    print(\"Status:\", LpStatus[prob.status])\n    for v in prob.variables():\n        print(v.name, \"=\", v.varValue)\n    print(\"Total Cost = \", value(prob.objective))\n\nこうして定義した関数を用いて配置する施設と，各需要点の施設への割り当てを求める。\n\nfacilitylocation(I,J,w,costs,p)\n\nWelcome to the CBC MILP Solver \nVersion: 2.10.10 \nBuild Date: Apr 19 2023 \n\ncommand line - cbc /var/folders/w6/pzry98n55l31dnvgymbwt9jh0000gn/T/8b46036933744d2db5bb7156cf4f5a18-pulp.mps timeMode elapsed branch printingOptions all solution /var/folders/w6/pzry98n55l31dnvgymbwt9jh0000gn/T/8b46036933744d2db5bb7156cf4f5a18-pulp.sol (default strategy 1)\nAt line 2 NAME          MODEL\nAt line 3 ROWS\nAt line 18 COLUMNS\nAt line 94 RHS\nAt line 108 BOUNDS\nAt line 124 ENDATA\nProblem MODEL has 13 rows, 15 columns and 35 elements\nCoin0008I MODEL read with 0 errors\nOption for timeMode changed from cpu to elapsed\nContinuous objective value is 100 - 0.00 seconds\nCgl0004I processed model has 13 rows, 15 columns (15 integer (15 of which binary)) and 35 elements\nCutoff increment increased from 1e-05 to 4.9999\nCbc0038I Initial state - 0 integers unsatisfied sum - 0\nCbc0038I Solution found of 100\nCbc0038I Before mini branch and bound, 15 integers at bound fixed and 0 continuous\nCbc0038I Mini branch and bound did not improve solution (0.00 seconds)\nCbc0038I After 0.00 seconds - Feasibility pump exiting with objective of 100 - took 0.00 seconds\nCbc0012I Integer solution of 100 found by feasibility pump after 0 iterations and 0 nodes (0.00 seconds)\nCbc0001I Search completed - best objective 100, took 0 iterations and 0 nodes (0.00 seconds)\nCbc0035I Maximum depth 0, 0 variables fixed on reduced cost\nCuts at root node changed objective from 100 to 100\nProbing was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nGomory was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nKnapsack was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nClique was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nMixedIntegerRounding2 was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nFlowCover was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nTwoMirCuts was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nZeroHalf was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n\nResult - Optimal solution found\n\nObjective value:                100.00000000\nEnumerated nodes:               0\nTotal iterations:               0\nTime (CPU seconds):             0.00\nTime (Wallclock seconds):       0.00\n\nOption for printingOptions changed from normal to all\nTotal time (CPU seconds):       0.00   (Wallclock seconds):       0.00\n\nStatus: Optimal\nx_0 = 1.0\nx_1 = 0.0\nx_2 = 0.0\nx_3 = 0.0\nx_4 = 1.0\ny_(0,_0) = 1.0\ny_(0,_1) = 0.0\ny_(0,_2) = 0.0\ny_(0,_3) = 0.0\ny_(0,_4) = 0.0\ny_(1,_0) = 0.0\ny_(1,_1) = 0.0\ny_(1,_2) = 0.0\ny_(1,_3) = 0.0\ny_(1,_4) = 1.0\nTotal Cost =  100.0\n\n\nこの出力結果から，最適解が求まったことがわかる。配置する施設は0と4であり，需要点0は施設0に，需要点1は施設4に掘り当てることが最適であることがわかる。また，その時の目的関数値は100であることもわかる。\n実際の地理情報を用いた例\n国土数値情報ダウンロードサイトから，医療機関データをダウンロードする。\nここのリストから，神奈川，世界測地系，令和2年のデータである，P04-20_13_GML.zipをダウンロードする。\nダウンロードしたファイルを解凍して，得られたフォルダをdataフォルダに収める。\nこうして得たファイルを，geopandasのread_file()により読み込む。\n\nimport matplotlib.pyplot as plt\nimport geopandas as gpd\n\n\nhosp=gpd.read_file('data/P04-20_13_GML/P04-20_13.geojson')\nhosp.head()\n\n\n\n\n\n\n\n\nP04_001\nP04_002\nP04_003\nP04_004\nP04_005\nP04_006\nP04_007\nP04_008\nP04_009\nP04_010\ngeometry\n\n\n\n\n0\n3\nキタカタ歯科医院\n江戸川区南篠崎町3-3-1　スイートヒルズ瑞江1階\n歯\nNaN\nNaN\n9\n0\n9\n9\nPOINT (139.90021 35.69387)\n\n\n1\n3\nスギタ歯科篠崎診療室\n江戸川区上篠崎2-4-3\n歯　小歯　矯歯　口外\nNaN\nNaN\n9\n0\n9\n9\nPOINT (139.90121 35.71164)\n\n\n2\n2\n江戸川区葛西健康サポ-トセンタ-\n江戸川区中葛西3-10-1\n内　小　歯\nNaN\nNaN\n9\n0\n9\n9\nPOINT (139.86965 35.66591)\n\n\n3\n2\n江戸川区江戸川保健所\n江戸川区中央4-24-19\n内　小　歯\nNaN\nNaN\n9\n0\n9\n9\nPOINT (139.86835 35.70958)\n\n\n4\n3\n西葛西ファミリー歯科\n江戸川区西葛西3-9-19　イオン葛西店4階\n歯　小歯　口外　矯歯\nNaN\nNaN\n9\n0\n9\n9\nPOINT (139.85850 35.66924)\n\n\n\n\n\n\n\nこのデータのうち，P04_001列に，医療機関の分類を示す値が含まれている。これが1なら病院，2なら診療所，3なら歯科診療所であることを示す。この列の値が1であるものを抜き出し，あらためてhospというデータにする。\n\nhosp=hosp[hosp[\"P04_001\"]==1]\n\nhospの先頭の5行を表示して確かに病院が抜き出されていることを確認する。\n\nhosp.head()\n\n\n\n\n\n\n\n\nP04_001\nP04_002\nP04_003\nP04_004\nP04_005\nP04_006\nP04_007\nP04_008\nP04_009\nP04_010\ngeometry\n\n\n\n\n81\n1\n３６６リハビリテーション病院\n府中市住吉町1-34-6\nリハビリ科\nNaN\nNaN\n4\n68\n9\n9\nPOINT (139.45764 35.66162)\n\n\n225\n1\nＪＲ東京総合病院\n渋谷区代々木2-1-3\n内科　呼吸器内科　循環器内科　消化器内科　脳神経内科　糖尿病内分泌内科　血液腫瘍内科　リウマ...\n放射線科　麻酔科　ペイン外科　臨床検査科　救急科　皮膚科　歯科口腔外科　病理診断科　血管外科\nNaN\n6\n425\n1\n9\nPOINT (139.69977 35.68569)\n\n\n317\n1\nＮＴＴ東日本関東病院\n品川区東五反田5-9-22\n内科　呼吸器内科　循環器内科　小児科　精神科　外科　整形外科　脳神経外科　心臓血管外科　産婦...\n腎臓内科　感染症内科　緩和ケア内科　脳神経内科　脳　血管内科　乳腺外科　呼吸器外科　頭頸部外...\nNaN\n6\n594\n1\n2\nPOINT (139.72554 35.63129)\n\n\n587\n1\nあきしま相互病院\n昭島市もくせいの杜2-2-1\n内科　精神科　リハビリ科\nNaN\nNaN\n4\n110\n9\n9\nPOINT (139.38428 35.71871)\n\n\n644\n1\nあけぼの病院\n町田市中町1-23-3\n内科　循環器内科　腎臓内科　人工透析内科　糖尿病内分泌内科　ペイン内科　外科　消化器外科　大...\nNaN\nNaN\n4\n98\n1\n9\nPOINT (139.44508 35.54962)\n\n\n\n\n\n\n\nこれから，特に町田市内の病院に注目する。そこで，東京都の行政区域を示すデータをダウンロードし，町田市の行政区域コード13209を用いて町田市のデータを取り出す。ダウンロードするのは，世界測地系，令和5年のデータである，N03-20230101_13_GMP.zipとする。\n\ntokyo=gpd.read_file('data/N03-20230101_13_GML/N03-23_13_230101.geojson')\nmachida=tokyo[tokyo[\"N03_007\"]=='13209'].copy()\n\n得られたmachidaをプロットして，確かに町田市の行政区域であることを確認する。\n\nmachida.plot()\n\n&lt;Axes: &gt;\n\n\n\n\n\n町田市内の病院を，geopandasのsjoinという演算を用いて取り出す。how=\"inner\"を指定することで，sjoin()の最初の引数hospからデータを取り出す。同時に，op=\"within\"を指定することで，machidaの区域（多角形）に含まれるhospの行を取り出す。\n\nhosp_in_machida=gpd.sjoin(hosp,machida,how=\"inner\",op=\"within\")\n\n/Users/kazuhiro/miniconda3/envs/nbdev/lib/python3.11/site-packages/IPython/core/interactiveshell.py:3448: FutureWarning: The `op` parameter is deprecated and will be removed in a future release. Please use the `predicate` parameter instead.\n  if await self.run_code(code, result, async_=asy):\n\n\nhosp_in_machidaの列のなかから，必要なものだけを抜き出したものを，あらためてhosp_in_machidaとする。\n\nhosp_in_machida=hosp_in_machida[['P04_001','P04_002','P04_003','P04_004','P04_008','P04_009','P04_010','geometry']]\n\nさらに，救急告示病院を抜き出したものを，em_hospとする。P04_009列が1であるものが，救急告示病院である。\n\nem_hosp=hosp_in_machida[hosp_in_machida[\"P04_009\"]==1]\n\n抜き出したままだとindexが飛び飛びの値になっているので，この番号をreset_index()によって振り直す。\n\nem_hosp=em_hosp.reset_index()\nem_hosp\n\n\n\n\n\n\n\n\nindex\nP04_001\nP04_002\nP04_003\nP04_004\nP04_008\nP04_009\nP04_010\ngeometry\n\n\n\n\n0\n644\n1\nあけぼの病院\n町田市中町1-23-3\n内科　循環器内科　腎臓内科　人工透析内科　糖尿病内分泌内科　ペイン内科　外科　消化器外科　大...\n98\n1\n9\nPOINT (139.44508 35.54962)\n\n\n1\n4530\n1\nふれあい町田ホスピタル\n町田市小山ヶ丘1-3-8\n内科　循環器内科　人工透析内科　神経内科　皮膚科　精神科　消化器外科　泌尿器科　脳神経外科　...\n199\n1\n9\nPOINT (139.38273 35.59798)\n\n\n2\n6509\n1\n医療法人社団　慶泉会　町田慶泉病院\n町田市南町田2-1-47\n内科　神経内科　外科　整形外科　泌尿器科　肛門外科　リハビリ科　麻酔科　血管外科　脳外科　腎臓内科\n148\n1\n9\nPOINT (139.47072 35.52103)\n\n\n3\n6599\n1\n医療法人社団　幸隆会　多摩丘陵病院\n町田市下小山田町1491\n内科　外科　消化器外科　整形外科　脳神経外科　婦人科　眼科　泌尿器科　リハビリ科　麻酔科　歯...\n316\n1\n9\nPOINT (139.42167 35.60461)\n\n\n4\n6681\n1\n医療法人社団　三医会　鶴川記念病院\n町田市三輪町1059-1\n内科　小児科　リハビリ科\n180\n1\n9\nPOINT (139.49661 35.57220)\n\n\n5\n7085\n1\n医療法人社団　創生会　町田病院\n町田市木曽東4-21-43\n内科　胃腸科　循環器科　精神科　神経科　外科　整形外科　脳神経外科　皮膚科　リハビリ科　救急...\n120\n1\n9\nPOINT (139.42529 35.56538)\n\n\n6\n17133\n1\n社会医療法人社団　正志会　南町田病院\n町田市鶴間4-4-1\n内科　呼吸器内科　消化器内科　循環器内科　神経内科　小児科　外科　呼吸器外科　消化器外科　乳...\n222\n1\n2\nPOINT (139.47121 35.50702)\n\n\n7\n21336\n1\n町田市民病院\n町田市旭町2-15-41\n内科　小児科　精神科　アレルギー科　リウマチ科　外科　整形外科　形成外科　脳神経外科　心臓血...\n447\n1\n2\nPOINT (139.43859 35.55705)\n\n\n\n\n\n\n\n得られた病院を，町田市の行政区域データと重ねて図示する。\n\nfig,ax=plt.subplots(figsize=(10,6))\nmachida.plot(ax=ax,color=\"white\",edgecolor=\"black\")\nem_hosp.plot(ax=ax,color=\"blue\",edgecolor=\"black\")\n\n&lt;Axes: &gt;\n\n\n\n\n\n次に，町田市内の各地域の人口データを用いて，各地域の病院の需要を設定する。まず，東京都の人口データをダウンロードする。国土数値情報ダウンロードサイトの「5.各種統計」の1kmメッシュ別将来推計人口データをダウンロードする。\nこれは，世界測地系，平成30年のデータであり，ファイル名は，1km_mesh_suikei_2018_shape_13.zipである。これを展開して，dataフォルダに移動する。\nこの中のshapefileを読み込み，SHICODE列（行政区域コード）が13209（町田市）のものを抜き出して，machida_popとする。\n\npop=gpd.read_file(\"data/1km_mesh_suikei_2018_shape_13/1km_mesh_2018_13.shp\")\nmachida_pop=pop[pop[\"SHICODE\"]==13209].copy()\n\n\nmachida_pop.plot()\n\n&lt;Axes: &gt;\n\n\n\n\n\n1kmメッシュの重点を求めるために，座標系をEPSG:2451とする。この2451は，距離が正しく測れる座標系の一つである。座標系を変換した後にmachida_pop.centroidによって各メッシュ（各行）のgeometryの重心を求めて，それを改めてmachida_popのcentroid列に覚えておく。\n\nmachida_pop=machida_pop.to_crs(epsg=2451)\nmachida_pop[\"centroid\"]=machida_pop[\"geometry\"].centroid\n\nmachida_popのcentroid列を，machida_popのgeometryとして設定する。このために，set_geometry()を用いる。\n\nmachida_pop.set_geometry(\"centroid\",inplace=True)\nmachida_pop.plot()\n\n&lt;Axes: &gt;\n\n\n\n\n\n\n\n\n&lt;Axes: &gt;"
  }
]